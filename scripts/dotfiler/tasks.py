
import os, sys, shutil, errno, glob
import os.path as path
from texthon.engine import Engine
import dotfiler.logger as log
import dotfiler.paths as paths

def mkdirp(task_name, path):
    try:
        os.makedirs(path)
        log.success("%s: mkdirp: %s" % (task_name, path))
    except:
        if os.path.exists(path) and os.path.isdir(path):
            log.notice("%s: mkdirp: '%s' already exists." % (task_name, path))
        else:
            raise

def exec_cmd(task_name, cmd):
    log.notice("%s: exec: %s" % (task_name, cmd))
    ret = system("git clone ")
    if ret != 0:
        log.error("%s: command '%s' failed with error code %d." % (task_name, cmd, ret))

def git_clone(task_name, fs_path, repo):
    if path.exists(fs_path):
        log.notice("%s: git-clone: '%s' already exists." % (task_name, fs_path))
        return
    exec_cmd(task_name, 'git clone "%s" "%s"' % (repo, fs_path))

def mklink(task_name, to_path, from_path):
    if path.exists(from_path):
        log.notice("%s: symlink: '%s' already exists." % (task_name, from_path))
        return
    os.symlink(to_path, from_path)
    log.success("%s: symlink: %s --> %s" % (task_name, from_path, to_path))

def copy_no_overwrite(task_name, orig_path, out_path):
    if path.exists(out_path):
        log.notice("%s: copy: '%s' already exists." % (task_name, out_path))
        return
    os.copy(orig_path, out_path)
    log.success("%s: copy: %s --> %s" % (task_name, orig_path, out_path))

def per_line_patch(task_name, out_path, added_lines=[], removed_lines=[]):
    content = ""
    try:
        with open(out_path) as f:
            content = f.read().decode("utf8")
    except:
        if path.exists(out_path):
            raise

    modified = False
    lines = content.splitlines()
    for line in added_lines:
        if line not in lines:
            lines.append(line)
            log.notice("%s: patch: adding '%s'" % (task_name, line))
            modified = True
    removed_lines = set(removed_lines)
    for line in lines:
        if line in removed_lines:
            log.notice("%s: patch: removing '%s'" % (task_name, line))
            modified = True
    lines = [line for line in lines if line not in removed_lines]

    if not modified:
        log.notice("%s: already patched: %s" % (task_name, out_path))
        return

    new_content = "\n".join(lines)
    with open(out_path, "w") as f:
        f.write(new_content)

    log.success("%s: patched: %s" % (task_name, out_path))

def concatenate(task_name, out_path, files, comment_fmt="# %s\n"):
    # expand globs
    files = [f
        for glb in files
        for f in sorted(glob.iglob(glb))]

    # overwrite check
    signature = comment_fmt % "This file was generated by dotfiler; do not edit"
    try:
        with open(out_path) as f:
            content = f.read().decode("utf8")
        if signature not in content:
            log.warn("%s: '%s' already exists and doesn't contain a banner; not overwriting" %
                (task_name, out_path))
            return
    except:
        pass

    sep = comment_fmt % ("-" * 30)

    # make file
    chunks = [signature]

    for file in files:
        chunks.append(sep)
        chunks.append(comment_fmt % file)
        chunks.append(sep)
        with open(file) as f:
            chunks.append(f.read())

    # write
    with open(out_path, 'w') as f:
        f.write(''.join(chunks))
    log.success(task_name + ": generated: " + out_path)


def translate(task_name, tmpl_path, out_path, parser):
    eng = Engine()
    module = eng.load_file(tmpl_path, parser)
    path = module.path
    eng.make()
    outp = eng.modules[path].main({
        "banner": "This file was generated by dotfiler; do not edit"
    })
    with open(out_path, "w") as f:
        f.write(outp)
    log.success(task_name + ": generated: " + out_path)